//#include <math.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include "kiss_fft.h"
//#include "fftwrap.h"

//#include "arch.h"
//#include "math_approx.h"
#include "exp_func.h"

#if defined(WIN32) && !defined(__cplusplus)

#define inline __inline

#endif


short ExpTbl2[128] = {
	5091, 4385, 3974, 3684, 3459, 3276, 3122, 2990,
	2873, 2769, 2675, 2590, 2512, 2440, 2373, 2311,
	2253, 2198, 2147, 2098, 2052, 2008, 1966, 1927,
	1889, 1852, 1817, 1784, 1752, 1721, 1691, 1662,
	1635, 1608, 1582, 1557, 1532, 1509, 1486, 1464,
	1442, 1421, 1401, 1381, 1362, 1343, 1324, 1306,
	1289, 1272, 1255, 1239, 1223, 1208, 1192, 1178,
	1163, 1149, 1135, 1121, 1108, 1095, 1082, 1069,
	1057, 1045, 1033, 1021, 1010, 999, 988, 977,
	966, 956, 945, 935, 925, 916, 906, 897,
	887, 878, 869, 860, 852, 843, 835, 826,
	818, 810, 802, 794, 787, 779, 771, 764,
	757, 750, 743, 736, 729, 722, 715, 709,
	702, 696, 689, 683, 677, 671, 665, 659,
	653, 647, 641, 636, 630, 625, 619, 614,
	609, 603, 598, 593, 588, 583, 578, 573
};
short ExpTbl[72] = {
	568, 498, 439, 389, 346, 309, 276, 248,
	223, 201, 182, 164, 149, 135, 123, 112,
	102, 93, 85, 77, 71, 65, 59, 54,
	50, 46, 42, 39, 35, 33, 30, 28,
	25, 23, 22, 20, 18, 17, 16, 14,
	13, 12, 11, 10, 10, 9, 8, 8,
	7, 7, 6, 6, 5, 5, 4, 4,
	4, 4, 3, 3, 3, 3, 2, 2,
	2, 2, 2, 2, 2, 1, 1, 1
};
short ExpTblk[72] = {
	-1056, -880, -752, -640, -560, -496, -416, -368,
	-320, -288, -272, -224, -208, -176, -176, -160,
	-144, -128, -112, -96, -96, -80, -64, -64,
	-64, -64, -48, -48, -32, -48, -32, -32,
	-16, -16, -32, -32, -16, -16, -32, -16,
	-16, -16, 0, 0, -16, -16, 0, -16,
	0, -16, 0, -16, 0, 0, 0, 0,
	0, -16, 0, 0, 0, -16, 0, 0,
	0, 0, 0, 0, -16, 0, 0, 0
};
int ExpIntfix(short in)//(0:5]*256 ExpIntfix(x*256) = expint(x)*1024
{
	int out;
	short addr1, addr2;
	addr1 = (short)((in - 1) >> 4);
	if (in == 0)
		in = 0;
	else if (addr1 == 80)
		addr1 = 80;
	if (in <= 128)
		out = ExpTbl2[in - 1];
	else
		if (addr1 <= 61)
		{
			addr2 = (short)((in - 1) & 0xf);
			out = (int)ExpTbl[addr1 - 8] + (((int)ExpTblk[addr1 - 8] * addr2) >> 8);
		}
		else
			out = ExpTbl[addr1 - 8];
	return out;
}

//调用方式log10_20fix(in(1:32768)) = 10*log10(in)*32 小数精度为5比特
short Tbl[128] = { 
	579, 771, 867, 923, 963, 994, 1020, 1041, 1060, 1076, 1091, 1104, 1116, 1127,
	1137, 1147, 1156, 1164, 1172, 1180, 1187, 1194, 1200, 1206, 1212, 1218, 1223, 1229, 1234,
	1239, 1243, 1248, 1252, 1257, 1261, 1265, 1269, 1272, 1276, 1280, 1283, 1287, 1290, 1293,
	1297, 1300, 1303, 1306, 1309, 1312, 1314, 1317, 1320, 1322, 1325, 1328, 1330, 1333, 1335,
	1337, 1340, 1342, 1344, 1346, 1349, 1351, 1353, 1355, 1357, 1359, 1361, 1363, 1365, 1367,
	1369, 1371, 1373, 1374, 1376, 1378, 1380, 1381, 1383, 1385, 1386, 1388, 1390, 1391, 1393,
	1394, 1396, 1398, 1399, 1401, 1402, 1404, 1405, 1406, 1408, 1409, 1411, 1412, 1413, 1415,
	1416, 1417, 1419, 1420, 1421, 1423, 1424, 1425, 1426, 1428, 1429, 1430, 1431, 1432, 1434,
	1435, 1436, 1437, 1438, 1439, 1441, 1442, 1443, 1444
};

unsigned char Tblk[64] = { 
	192, 96, 56, 40, 31, 26, 21, 19, 
	16, 15, 13, 12, 11, 10, 10, 9, 
	8, 8, 8, 7, 7, 6, 6, 6, 
	6, 5, 6, 5, 5, 4, 5, 4,
	5, 4, 4, 4, 3, 4, 4, 3,
	4, 3, 3, 4, 3, 3, 3, 3,
	2, 2, 3, 3, 2, 3, 3, 2, 
	3, 2, 2, 3, 2, 2, 2, 3 
};

short Tbl2[128] = { 
	0, 96, 153, 193, 224, 249, 270, 289, 
	305, 320, 333, 345, 356, 367, 376, 385,
	394,402, 409, 416, 423, 430, 436, 442, 
	447, 453, 458, 463, 468, 473, 477, 482,
	486, 490, 494, 498, 502, 506, 509, 513,
	516, 519, 523, 526, 529, 532, 535,538, 
	541, 544, 546, 549, 552, 554, 557, 559, 
	562, 564, 567, 569, 571, 574, 576, 578, 
	580, 582, 584, 586, 588, 590, 592, 594, 
	596, 598, 600, 602, 604,605, 607, 609, 
	611, 612, 614, 616, 617, 619, 621, 622,
	624, 625, 627, 628,630, 631, 633, 634,
	636, 637, 639, 640, 641, 643, 644, 645,
	647, 648, 649,651, 652, 653, 655, 656,
	657, 658, 659, 661, 662, 663, 664, 665, 
	666, 668,669, 670, 671, 672, 673, 674 
};

int log10_20fix(int in)
{
	int out;
	short addr1, addr2;
	addr1 = (short)((in - 1) >> 8);
        if(in<=1)
          in = 1;
	if (in <= 128)
		out = Tbl2[in - 1];
	else
		if (addr1 <= 63)
		{
			addr2 = (short)((in - 1) & 0xff);
			out = (int)Tbl[addr1] + (((int)Tblk[addr1] * addr2) >> 8);
		}
		else
			out = Tbl[addr1];
	return (out);
}

short log10Tbl1[32] = { -482, -239, -192, -164, -144, -129, -116, -105,
						-96, -88, -81, -74, -68, -62, -57, -53,
						-48, -44, -40, -36, -33, -29, -26, -23,
						-20, -17, -14, -12, -9, -7, -4, -2 };
short log10Tbl2[64] = { -482, -433, -405, -385, -370, -357, -346, -337,
						-329, -322, -315, -309, -303, -298, -293, -289,
						-285, -281, -277, -273, -270, -267, -264, -261,
						-258, -255, -253, -250, -248, -245, -243, -241,
						-239, -237, -235, -233, -231, -229, -227, -225,
						-224, -222, -220, -219, -217, -216, -214, -213,
						-211, -210, -208, -207, -206, -204, -203, -202,
						-201, -199, -198, -197, -196, -195, -194, -193 };
short log10Tblk2[32] = { 1928, 368, 224, 160, 120, 104, 80, 72,
						64, 56, 56, 48, 40, 40, 32, 40,
						32, 32, 32, 24, 32, 24, 24, 24,
						24, 24, 16, 24, 16, 24, 16, 16 };


int log10dotfun(short in)//log10dotfun(in*1024) = 10*log10(in)*32
{
	int out;
	short addr1, addr2, tmp;
	tmp = in - 1;
	if (tmp<0)
		tmp = 0;
	addr1 = (short)(tmp >> 5);
	if (in <= 64)
		out = log10Tbl2[tmp];
	else
	{
		addr2 = (short)(tmp & 0x1f);
		out = (int)log10Tbl1[addr1] + (((int)log10Tblk2[addr1] * addr2) >> 8);
	}
	return out;
}


static  inline int spx_exp2(short x)
{
	int integer;
	int frac;
	integer = SHR16F(x, 11);
	if (integer>14)
		return 0x7fffffff;
	else if (integer < -15)
		return 0;
	frac = SHL16F(x - SHL16F(integer, 11), 3);
	frac = ADD16F(D0, MULT16_16_Q14F(frac, ADD16F(D1, MULT16_16_Q14F(frac, ADD16F(D2, MULT16_16_Q14F(D3, frac))))));
	return VSHR32F(EXTEND32F(frac), -integer - 2);
}

/* Input in Q11 format, output in Q16 */
static inline int spx_exp(short x)//输入*2^11  输出/2^14
{
	if (x>21290)
		return 0x7fffffff;
	else if (x<-21290)
		return 0;
	else
		return spx_exp2(MULT16_16_P14F(23637, x));
}


int exp_fix(short x)
{
	return spx_exp(x);
}


static inline short fix_ilog4(int x)
{
	int r = 0;
	if (x >= (int)65536)
	{
		x >>= 16;
		r += 8;
	}
	if (x >= 256)
	{
		x >>= 8;
		r += 4;
	}
	if (x >= 16)
	{
		x >>= 4;
		r += 2;
	}
	if (x >= 4)
	{
		r += 1;
	}
	return r;
}


 short sqrt_fix(int x)
{
	int k;
	int rt;
	k = fix_ilog4(x) - 6;
	x = VSHR32F(x, (k << 1));
	rt = ADD16F(C0, MULT16_16_Q14F(x, ADD16F(C1, MULT16_16_Q14F(x, ADD16F(C2, MULT16_16_Q14F(x, (C3)))))));
	rt = VSHR32F(rt, 7 - k);
	return rt;
}

